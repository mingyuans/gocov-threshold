diff --git a/.github/workflows/integration.yaml b/.github/workflows/integration.yaml
new file mode 100644
index 0000000..7015c2d
--- /dev/null
+++ b/.github/workflows/integration.yaml
@@ -0,0 +1,26 @@
+name: Integration Test
+
+on:
+  pull_request:
+
+jobs:
+  build:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v3
+        with:
+          fetch-depth: 0
+
+      - name: Go Test
+        run: |
+          go test ./example/... -coverprofile=coverage.out
+
+      - name: Coverage Threshold
+        id: coverage_threshold
+        uses: mingyuans/gocov-threshold@dev
+        with:
+          path: .
+          coverprofile: coverage.out
+          module: github.com/mingyuans/gocov-threshold
+          logger-level: debug
+          token: ${{ secrets.GITHUB_TOKEN }}
\ No newline at end of file
diff --git a/Dockerfile b/Dockerfile
new file mode 100644
index 0000000..846b874
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,12 @@
+FROM golang:1.24-alpine3.21
+
+WORKDIR /gocov-threshold
+COPY . /gocov-threshold
+
+
+RUN go mod download
+RUN go mod tidy
+
+RUN cd cmd/threshold && go install
+
+CMD ["threshold"]
\ No newline at end of file
diff --git a/action.yaml b/action.yaml
new file mode 100644
index 0000000..2230504
--- /dev/null
+++ b/action.yaml
@@ -0,0 +1,29 @@
+name: "Go Coverage Threshold Action"
+description: "Show coverage difference between branches in a pull request"
+author: "Jimmy Yan"
+inputs:
+  path:
+    description: "path to git repo"
+    default: "."
+  coverprofile:
+    description: "path to coverage profile"
+  module:
+    description: "the Go module name"
+  ignore-main:
+    default: "true"
+    description: "ignore main package"
+  threshold:
+    description: "coverage threshold (0-100)"
+    default: "80"
+  logger-level:
+    description: "logger level (debug, info, warn, error)"
+    default: "info"
+  token:
+    description: "GitHub token for API access"
+    default: ${{ github.token }}
+outputs:
+  covdiff:
+    description: "the coverage difference (0-100)"
+runs:
+  using: "docker"
+  image: "Dockerfile"
diff --git a/cmd/threshold/arg/arg.go b/cmd/threshold/arg/arg.go
new file mode 100644
index 0000000..164a338
--- /dev/null
+++ b/cmd/threshold/arg/arg.go
@@ -0,0 +1,39 @@
+package arg
+
+import (
+	"fmt"
+	"os"
+	"strings"
+)
+
+type Arg struct {
+	IgnoreMain   bool
+	Module       string
+	Threshold    int
+	Path         string
+	Coverprofile string
+	LoggerLevel  string
+	GithubToken  string
+}
+
+// ParseArg parses command-line flags into an Arg struct.
+func ParseArg() Arg {
+	var a Arg
+	a.IgnoreMain = getActionInput("ignore-main") == "true"
+	a.Module = getActionInput("module")
+	a.Threshold = 80
+	if threshold := getActionInput("threshold"); threshold != "" {
+		_, _ = fmt.Sscanf(threshold, "%d", &a.Threshold)
+	}
+	a.Path = getActionInput("path")
+	a.Coverprofile = getActionInput("coverprofile")
+	a.LoggerLevel = getActionInput("logger-level")
+	a.GithubToken = getActionInput("token")
+	return a
+}
+
+func getActionInput(input string) string {
+	return os.Getenv(
+		fmt.Sprintf("INPUT_%s", strings.ToUpper(input)),
+	)
+}
diff --git a/cmd/threshold/log/log.go b/cmd/threshold/log/log.go
new file mode 100644
index 0000000..4545fec
--- /dev/null
+++ b/cmd/threshold/log/log.go
@@ -0,0 +1,25 @@
+package log
+
+import (
+	"go.uber.org/zap"
+	"sync"
+)
+
+var (
+	gLogger *zap.Logger
+	once    sync.Once
+)
+
+func Init(level string) {
+	cfg := zap.NewProductionConfig()
+	zapLevel, parseErr := zap.ParseAtomicLevel(level)
+	if parseErr != nil {
+		panic("Failed to parse log level: " + parseErr.Error())
+	}
+	cfg.Level = zapLevel
+	gLogger, _ = cfg.Build()
+}
+
+func Get() *zap.Logger {
+	return gLogger
+}
diff --git a/cmd/threshold/main.go b/cmd/threshold/main.go
new file mode 100644
index 0000000..5aac33d
--- /dev/null
+++ b/cmd/threshold/main.go
@@ -0,0 +1,25 @@
+package main
+
+import (
+	"fmt"
+	"github.com/mingyuans/gocov-threshold/cmd/threshold/arg"
+	"github.com/mingyuans/gocov-threshold/cmd/threshold/log"
+	"github.com/mingyuans/gocov-threshold/cmd/threshold/pr"
+	"go.uber.org/zap"
+)
+
+func main() {
+	actionArg := arg.ParseArg()
+	log.Init(actionArg.LoggerLevel)
+	log.Get().Debug("Arguments parsed", zap.Any("arg", actionArg))
+	fmt.Printf("Parsed arguments: %+v\n", actionArg)
+
+	prService := pr.NewService(actionArg)
+	log.Get().Debug("PR Service initialized", zap.Any("env", prService.GetEnvironment()),
+		zap.Any("pr", prService.GetPRInfo()))
+
+	downloadErr := prService.DownloadAndSaveDiff("pr.diff")
+	if downloadErr != nil {
+		panic(fmt.Sprintf("Failed to download and save PR diff: %s", downloadErr.Error()))
+	}
+}
diff --git a/cmd/threshold/pr/download.go b/cmd/threshold/pr/download.go
new file mode 100644
index 0000000..3e58268
--- /dev/null
+++ b/cmd/threshold/pr/download.go
@@ -0,0 +1,72 @@
+package pr
+
+import (
+	"fmt"
+	"github.com/mingyuans/gocov-threshold/cmd/threshold/log"
+	"go.uber.org/zap"
+	"io"
+	"net/http"
+	"os"
+	"time"
+)
+
+func (srv Service) DownloadDiff() (string, error) {
+	diffURL := fmt.Sprintf("%s/repos/%s/%s/pulls/%d",
+		srv.env.APIServerURL,
+		srv.env.RepositoryOwner,
+		srv.env.RepositoryName,
+		srv.info.Number)
+
+	log.Get().Debug("Downloading diff from URL", zap.String("diffURL", diffURL))
+
+	// Create request
+	req, err := http.NewRequest("GET", diffURL, nil)
+	if err != nil {
+		return "", fmt.Errorf("failed to create request: %w", err)
+	}
+
+	// Set authentication headers
+	req.Header.Set("Authorization", "Bearer "+srv.inputArg.GithubToken)
+	req.Header.Set("Accept", "application/vnd.github.diff")
+	req.Header.Set("User-Agent", "GitHub-Action-PR-Diff-Downloader")
+
+	// Send request
+	client := &http.Client{Timeout: 60 * time.Second}
+	resp, err := client.Do(req)
+	if err != nil {
+		return "", fmt.Errorf("failed to download diff: %w", err)
+	}
+	defer resp.Body.Close()
+
+	if resp.StatusCode != http.StatusOK {
+		return "", fmt.Errorf("diff download failed with status %d", resp.StatusCode)
+	}
+
+	// Read response content
+	content, err := io.ReadAll(resp.Body)
+	if err != nil {
+		return "", fmt.Errorf("failed to read diff content: %w", err)
+	}
+
+	return string(content), nil
+}
+
+func saveDiffToFile(content, filename string) error {
+	return os.WriteFile(filename, []byte(content), 0644)
+}
+
+func (srv Service) DownloadAndSaveDiff(filename string) error {
+	diffContent, err := srv.DownloadDiff()
+	if err != nil {
+		return fmt.Errorf("failed to download diff: %w", err)
+	}
+
+	log.Get().Debug("Downloading diff from URL", zap.String("diffContent", diffContent))
+
+	if err := saveDiffToFile(diffContent, filename); err != nil {
+		return fmt.Errorf("failed to save diff to file: %w", err)
+	}
+
+	log.Get().Info("Diff downloaded and saved successfully", zap.String("filename", filename))
+	return nil
+}
diff --git a/cmd/threshold/pr/env.go b/cmd/threshold/pr/env.go
new file mode 100644
index 0000000..7070e29
--- /dev/null
+++ b/cmd/threshold/pr/env.go
@@ -0,0 +1,173 @@
+package pr
+
+import (
+	"encoding/json"
+	"fmt"
+	"github.com/mingyuans/gocov-threshold/cmd/threshold/arg"
+	"github.com/mingyuans/gocov-threshold/cmd/threshold/log"
+	"net/http"
+	"os"
+	"strconv"
+	"strings"
+	"time"
+)
+
+func getPREnvironment() Environment {
+	repository := os.Getenv("GITHUB_REPOSITORY")
+
+	var repositoryName = ""
+	parts := strings.Split(repository, "/")
+	if len(parts) == 2 {
+		repositoryName = parts[1]
+	}
+
+	return Environment{
+		Repository:      repository,
+		RepositoryName:  repositoryName,
+		EventName:       os.Getenv("GITHUB_EVENT_NAME"),
+		EventPath:       os.Getenv("GITHUB_EVENT_PATH"),
+		RefName:         os.Getenv("GITHUB_REF_NAME"),
+		RepositoryOwner: os.Getenv("GITHUB_REPOSITORY_OWNER"),
+		SHA:             os.Getenv("GITHUB_SHA"),
+		Actor:           os.Getenv("GITHUB_ACTOR"),
+		ServerURL:       getEnvWithDefault("GITHUB_SERVER_URL", "https://github.com"),
+		APIServerURL:    getEnvWithDefault("GITHUB_API_URL", "https://api.github.com"),
+	}
+}
+
+func getEnvWithDefault(key, defaultValue string) string {
+	if value := os.Getenv(key); value != "" {
+		return value
+	}
+	return defaultValue
+}
+
+func (srv Service) GetEnvironment() Environment {
+	return srv.env
+}
+
+type Environment struct {
+	Repository      string // GITHUB_REPOSITORY
+	RepositoryName  string
+	EventName       string // GITHUB_EVENT_NAME
+	EventPath       string // GITHUB_EVENT_PATH
+	RepositoryOwner string // GITHUB_REPOSITORY_OWNER
+	RefName         string // GITHUB_REF_NAME
+	SHA             string // GITHUB_SHA
+	Actor           string // GITHUB_ACTOR
+	ServerURL       string // GITHUB_SERVER_URL
+	APIServerURL    string // GITHUB_API_URL
+}
+
+type GitHubPRInfo struct {
+	Number   int    `json:"number"`
+	Title    string `json:"title"`
+	HtmlURL  string `json:"html_url"`
+	DiffURL  string `json:"diff_url"`
+	PatchURL string `json:"patch_url"`
+	Head     struct {
+		SHA string `json:"sha"`
+		Ref string `json:"ref"`
+	} `json:"head"`
+	Base struct {
+		SHA string `json:"sha"`
+		Ref string `json:"ref"`
+	} `json:"base"`
+	State string `json:"state"`
+}
+
+type PullRequestEvent struct {
+	Number      int          `json:"number"`
+	PullRequest GitHubPRInfo `json:"pull_request"`
+	Repository  struct {
+		Name     string `json:"name"`
+		FullName string `json:"full_name"`
+		Owner    struct {
+			Login string `json:"login"`
+		} `json:"owner"`
+	} `json:"repository"`
+	Action string `json:"action"`
+}
+
+func gettPRInfo(env Environment, arg arg.Arg) (GitHubPRInfo, error) {
+	if env.EventPath != "" {
+		if prInfo, err := getPRInfoFromEventFile(env.EventPath); err == nil {
+			return prInfo, nil
+		}
+		log.Get().Debug("⚠️  Failed to read from event file, trying API...")
+	}
+
+	return getPRInfoFromAPI(env, arg)
+}
+
+func (srv Service) GetPRInfo() GitHubPRInfo {
+	return srv.info
+}
+
+func getPRInfoFromEventFile(eventPath string) (GitHubPRInfo, error) {
+	prInfo := GitHubPRInfo{}
+	data, err := os.ReadFile(eventPath)
+	if err != nil {
+		return prInfo, fmt.Errorf("failed to read event file: %w", err)
+	}
+
+	var event PullRequestEvent
+	if err := json.Unmarshal(data, &event); err != nil {
+		return prInfo, fmt.Errorf("failed to parse event JSON: %w", err)
+	}
+
+	return event.PullRequest, nil
+}
+
+func getPRInfoFromAPI(env Environment, arg arg.Arg) (GitHubPRInfo, error) {
+	prInfo := GitHubPRInfo{}
+	//The for: refs/pull/{pr_number}/merge
+	prNumber, err := extractPRNumber(env.RefName, env.SHA)
+	if err != nil {
+		return prInfo, fmt.Errorf("failed to extract PR number: %w", err)
+	}
+
+	apiURL := fmt.Sprintf("%s/repos/%s/pulls/%d", env.APIServerURL, env.Repository, prNumber)
+
+	req, err := http.NewRequest("GET", apiURL, nil)
+	if err != nil {
+		return prInfo, fmt.Errorf("failed to create request: %w", err)
+	}
+
+	req.Header.Set("Authorization", "token "+arg.GithubToken)
+	req.Header.Set("Accept", "application/vnd.github.v3+json")
+	req.Header.Set("User-Agent", "mingyuans/gocov-threshold")
+
+	client := &http.Client{Timeout: 30 * time.Second}
+	resp, err := client.Do(req)
+	if err != nil {
+		return prInfo, fmt.Errorf("failed to send request: %w", err)
+	}
+	defer resp.Body.Close()
+
+	if resp.StatusCode != http.StatusOK {
+		return prInfo, fmt.Errorf("API request failed with status %d", resp.StatusCode)
+	}
+
+	// 解析响应
+	if decodeErr := json.NewDecoder(resp.Body).Decode(&prInfo); decodeErr != nil {
+		return prInfo, fmt.Errorf("failed to decode response: %w", decodeErr)
+	}
+
+	return prInfo, nil
+}
+
+func extractPRNumber(refName, sha string) (int, error) {
+	if strings.HasPrefix(refName, "refs/pull/") {
+		parts := strings.Split(refName, "/")
+		if len(parts) >= 3 {
+			return strconv.Atoi(parts[2])
+		}
+	}
+
+	if prNum, err := strconv.Atoi(refName); err == nil {
+		return prNum, nil
+	}
+
+	return 0, fmt.Errorf("unable to extract PR number from ref: %s", refName)
+}
diff --git a/cmd/threshold/pr/pr.go b/cmd/threshold/pr/pr.go
new file mode 100644
index 0000000..fbd4268
--- /dev/null
+++ b/cmd/threshold/pr/pr.go
@@ -0,0 +1,22 @@
+package pr
+
+import "github.com/mingyuans/gocov-threshold/cmd/threshold/arg"
+
+type Service struct {
+	env      Environment
+	info     GitHubPRInfo
+	inputArg arg.Arg
+}
+
+func NewService(inputArg arg.Arg) *Service {
+	env := getPREnvironment()
+	info, getInfoErr := gettPRInfo(env, inputArg)
+	if getInfoErr != nil {
+		panic("Failed to get PR info: " + getInfoErr.Error())
+	}
+	return &Service{
+		env:      env,
+		info:     info,
+		inputArg: inputArg,
+	}
+}
diff --git a/example/main.go b/example/main.go
new file mode 100644
index 0000000..880ee44
--- /dev/null
+++ b/example/main.go
@@ -0,0 +1,25 @@
+package main
+
+import "math/rand"
+
+func main() {
+	value := rand.Intn(100)
+	exampleFunc(value)
+	exampleFunc2(value)
+}
+
+func exampleFunc(value int) {
+	if value%2 == 0 {
+		println("Even")
+	} else {
+		println("Odd")
+	}
+}
+
+func exampleFunc2(value int) {
+	if value%3 == 0 {
+		println("Divisible by 3")
+	} else {
+		println("Not divisible by 3")
+	}
+}
diff --git a/example/main_test.go b/example/main_test.go
new file mode 100644
index 0000000..f29423e
--- /dev/null
+++ b/example/main_test.go
@@ -0,0 +1,15 @@
+package main
+
+import "testing"
+
+func Test_exampleFunc(t *testing.T) {
+	t.Run("exampleFunc", func(t *testing.T) {
+		exampleFunc(1)
+	})
+}
+
+func Test_exampleFunc2(t *testing.T) {
+	t.Run("exampleFunc2", func(t *testing.T) {
+		exampleFunc2(3)
+	})
+}
diff --git a/go.mod b/go.mod
new file mode 100644
index 0000000..3f37764
--- /dev/null
+++ b/go.mod
@@ -0,0 +1,8 @@
+module github.com/mingyuans/gocov-threshold
+
+go 1.24.2
+
+require (
+	go.uber.org/multierr v1.11.0 // indirect
+	go.uber.org/zap v1.27.0 // indirect
+)